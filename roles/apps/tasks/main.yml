---
# ---------- Paquetes base ----------
- name: Instalar paquetes base
  apt:
    name: "{{ apt_base_packages }}"
    update_cache: yes
  become: yes

- name: Instalar unclutter (oculta cursor inactivo)
  apt:
    name: unclutter
    state: present
    update_cache: yes
  become: yes

# Lo esencial para pantalla:
- name: Paquetes base de display (x11/xset)
  apt:
    name:
      - x11-xserver-utils
    state: present
    update_cache: yes
  become: yes

# CEC opcional: intenta instalar y si falla, no rompas el play
- name: Instalar cec-utils (opcional)
  apt:
    name: cec-utils
    state: present
    update_cache: yes
  become: yes
  ignore_errors: yes
  register: cec_install

- name: Aviso cec-utils no se pudo instalar, se deja opcional
  debug:
    msg: "cec-utils falló por dependencias (mezcla de versiones). Seguimos sin CEC."
  when: cec_install is failed

# ---------- Directorios ----------
- name: Crear directorios base
  file:
    path: "{{ item }}"
    state: directory
    owner: "{{ kiosk_user }}"
    group: "{{ kiosk_user }}"
    mode: "0755"
  loop:
    - "{{ electron_root }}"
    - "{{ signage_root }}"
  become: yes

# --- SSH keys en el target ---
- name: Crear ~/.ssh
  file:
    path: "/home/{{ kiosk_user }}/.ssh"
    state: directory
    owner: "{{ kiosk_user }}"
    group: "{{ kiosk_user }}"
    mode: "0700"
  become: yes

- name: Copiar llave electron
  copy:
    src: "{{ playbook_dir }}/secrets/id_ed25519_electron"
    dest: "/home/{{ kiosk_user }}/.ssh/id_ed25519_electron"
    mode: "0600"
    owner: "{{ kiosk_user }}"
    group: "{{ kiosk_user }}"
  become: yes
  no_log: true

- name: Copiar llave signage
  copy:
    src: "{{ playbook_dir }}/secrets/id_ed25519_signage"
    dest: "/home/{{ kiosk_user }}/.ssh/id_ed25519_signage"
    mode: "0600"
    owner: "{{ kiosk_user }}"
    group: "{{ kiosk_user }}"
  become: yes
  no_log: true

- name: Asegurar known_hosts (GitHub)
  known_hosts:
    name: github.com
    key: "{{ lookup('pipe', 'ssh-keyscan -t rsa,ecdsa,ed25519 github.com') }}"
    path: "/home/{{ kiosk_user }}/.ssh/known_hosts"
    state: present
  become: yes
  become_user: "{{ kiosk_user }}"

- name: Configurar ~/.ssh/config (default + alias github-signage)
  blockinfile:
    path: "/home/{{ kiosk_user }}/.ssh/config"
    create: yes
    owner: "{{ kiosk_user }}"
    group: "{{ kiosk_user }}"
    mode: "0600"
    block: |
      Host github.com
        HostName github.com
        User git
        IdentityFile ~/.ssh/id_ed25519_electron
        IdentitiesOnly yes
        StrictHostKeyChecking accept-new

      # Usa este alias solo si el remoto de signage es git@github-signage:...
      Host github-signage
        HostName github.com
        User git
        IdentityFile ~/.ssh/id_ed25519_signage
        IdentitiesOnly yes
        StrictHostKeyChecking accept-new
  become: yes

# Solo si tu remoto de signage usa git@github-signage:...
- name: Config ~/.ssh/config con alias github-signage
  blockinfile:
    path: "/home/{{ kiosk_user }}/.ssh/config"
    create: yes
    owner: "{{ kiosk_user }}"
    group: "{{ kiosk_user }}"
    mode: "0600"
    block: |
      Host github.com
        User git
        IdentityFile ~/.ssh/id_ed25519_electron
        IdentitiesOnly yes

      Host github-signage
        HostName github.com
        User git
        IdentityFile ~/.ssh/id_ed25519_signage
        IdentitiesOnly yes
  when: electron_repo is search('github-signage') or signage_repo is search('github-signage')
  become: yes

# ---------- Clonar/actualizar repos ----------
- name: Clonar/actualizar electron_rasp
  git:
    repo: "{{ electron_repo }}"
    dest: "{{ electron_root }}/electron_rasp"
    version: "{{ electron_branch }}"
    force: yes
    accept_hostkey: yes
    key_file: "/home/{{ kiosk_user }}/.ssh/id_ed25519_electron"
  become: yes
  become_user: "{{ kiosk_user }}"

- name: Clonar/actualizar signage
  git:
    repo: "{{ signage_repo }}"
    dest: "{{ signage_root }}/signage"
    version: "{{ signage_branch }}"
    force: yes
    accept_hostkey: yes
    key_file: "/home/{{ kiosk_user }}/.ssh/id_ed25519_signage"
  become: yes
  become_user: "{{ kiosk_user }}"

# ---------- Python venv + requirements ----------
- name: Crear venv (si no existe)
  command: "{{ python_bin }} -m venv {{ venv_dir }}"
  args: { creates: "{{ venv_dir }}/bin/activate" }
  become: yes
  become_user: "{{ kiosk_user }}"

- name: Instalar requirements (Flask)
  command: "{{ venv_dir }}/bin/pip install --upgrade -r {{ requirements_file }}"
  become: yes
  become_user: "{{ kiosk_user }}"

# ---------- NPM para Electron ----------
- name: Instalar dependencias npm (electron)
  command: npm ci
  args:
    chdir: "{{ electron_app_dir }}"
  become: yes
  become_user: "{{ kiosk_user }}"

# ---------- Scripts de auto-pull (copiados 1:1 de tu Pi) ----------
- name: Instalar update_repo.sh (electron)
  copy:
    src: update_repo.sh
    dest: "{{ electron_root }}/update_repo.sh"
    mode: "0755"
    owner: "{{ kiosk_user }}"
    group: "{{ kiosk_user }}"
  become: yes

- name: Instalar signage update.sh
  copy:
    src: signage_update.sh
    dest: "{{ signage_root }}/signage/update.sh"
    mode: "0755"
    owner: "{{ kiosk_user }}"
    group: "{{ kiosk_user }}"
  become: yes

# ---------- systemd: services/timers ----------
- name: electron_rasp-electron.service
  template:
    src: electron_rasp-electron.service.j2
    dest: /etc/systemd/system/electron_rasp-electron.service
    mode: "0644"
  notify: [reload systemd]
  become: yes

- name: Crear dir para drop-ins de electron
  file:
    path: /etc/systemd/system/electron_rasp-electron.service.d
    state: directory
    mode: "0755"
  become: yes

- name: Drop-in override (CPU + flags)
  template:
    src: electron_rasp-electron.override.conf.j2
    dest: /etc/systemd/system/electron_rasp-electron.service.d/override.conf
    mode: "0644"
  notify: [reload systemd]
  become: yes

- name: electron_rasp-flask.service
  template:
    src: electron_rasp-flask.service.j2
    dest: /etc/systemd/system/electron_rasp-flask.service
    mode: "0644"
  notify: [reload systemd]
  become: yes

- name: electron_rasp-update.service
  template:
    src: electron_rasp-update.service.j2
    dest: /etc/systemd/system/electron_rasp-update.service
    mode: "0644"
  notify: [reload systemd]
  become: yes

- name: electron_rasp-update.timer
  template:
    src: electron_rasp-update.timer.j2
    dest: /etc/systemd/system/electron_rasp-update.timer
    mode: "0644"
  notify: [reload systemd]
  become: yes

- name: signage-update.service
  template:
    src: signage-update.service.j2
    dest: /etc/systemd/system/signage-update.service
    mode: "0644"
  notify: [reload systemd]
  become: yes

- name: signage-update.timer
  template:
    src: signage-update.timer.j2
    dest: /etc/systemd/system/signage-update.timer
    mode: "0644"
  notify: [reload systemd]
  become: yes

- name: Habilitar y arrancar servicios/timers
  systemd:
    name: "{{ item }}"
    enabled: yes
    state: started
  loop:
    - electron_rasp-flask.service
    - electron_rasp-electron.service
    - electron_rasp-update.timer
    - signage-update.timer
  become: yes

# ---------- LightDM autologin (opcional) ----------
- name: Configurar autologin en LightDM (opcional)
  ini_file:
    path: /etc/lightdm/lightdm.conf
    section: "Seat:*"
    option: "{{ item.option }}"
    value: "{{ item.value }}"
    no_extra_spaces: true
    backup: yes
  loop:
    - { option: "autologin-user",   value: "{{ lightdm_autologin_user }}" }
    - { option: "autologin-session", value: "{{ lightdm_session }}" }
    - { option: "user-session",      value: "{{ lightdm_session }}" }
    - { option: "xserver-command",   value: "X" }
  when: manage_lightdm
  become: yes

- name: Habilitar lightdm (display manager)
  systemd:
    name: lightdm.service
    enabled: yes
    state: started
  when: manage_lightdm
  become: yes

- name: Crear carpeta de autostart del usuario
  file:
    path: "/home/{{ kiosk_user }}/.config/lxsession/{{ lightdm_session }}"
    state: directory
    owner: "{{ kiosk_user }}"
    group: "{{ kiosk_user }}"
    mode: "0755"
  become: yes

- name: Autostart LXDE sin DPMS
  copy:
    dest: "/home/{{ kiosk_user }}/.config/lxsession/{{ lightdm_session }}/autostart"
    owner: "{{ kiosk_user }}"
    group: "{{ kiosk_user }}"
    mode: "0644"
    content: |
      @xset s off
      @xset -dpms
      @xset s noblank
      @unclutter -idle 0.5 -root
  become: yes

- name: Instalar unit signage-update.service
  template:
    src: signage-update.service.j2
    dest: /etc/systemd/system/signage-update.service
    owner: root
    group: root
    mode: '0644'
  notify: [reload systemd]

- name: Asegurar timer habilitado
  systemd:
    name: signage-update.timer
    enabled: yes
    state: started
  become: yes

# --- TeamViewer/AnyDesk: endurecer arranque y diagnóstico ---

- name: Recoger facts de servicios
  service_facts:

# 1) Normaliza lista de remotos (cubre teamviewer y teamviewerd)
- name: Construir lista final de remotos
  set_fact:
    remote_services_final: >-
      {{ ((remote_services | default([]))
          + ['teamviewer.service', 'teamviewerd.service']) | unique }}

# 2) Quitar hard-mask si existe (symlink -> /dev/null)
- name: Detectar hard-mask (symlink a /dev/null)
  stat:
    path: "/etc/systemd/system/teamviewerd.service"
  register: tvd_unit
  become: yes

- name: Eliminar hard-mask de teamviewerd
  file:
    path: "/etc/systemd/system/teamviewerd.service"
    state: absent
  when: tvd_unit.stat.islnk is defined and tvd_unit.stat.islnk and tvd_unit.stat.lnk_target == '/dev/null'
  become: yes

- name: systemd daemon-reload tras quitar hard-mask
  systemd:
    daemon_reload: yes
  become: yes

# 3) Drop-in para hacer el servicio más resiliente (restart + network-online)
- name: Crear carpeta de drop-ins para teamviewerd
  file:
    path: /etc/systemd/system/teamviewerd.service.d
    state: directory
    mode: "0755"
  become: yes

- name: Drop-in override de teamviewerd (Restart + After network-online)
  copy:
    dest: /etc/systemd/system/teamviewerd.service.d/override.conf
    mode: "0644"
    content: |
      [Unit]
      Wants=network-online.target
      After=network-online.target

      [Service]
      Restart=on-failure
      RestartSec=3s
  notify: reload systemd
  become: yes

# 4) Unmask + enable + start vía systemd para cada servicio que exista
- name: Asegurar remotos unmasked/enabled/started (systemd)
  systemd:
    name: "{{ item }}"
    masked: no
    enabled: yes
    state: started
  loop: "{{ remote_services_final }}"
  when: item in (ansible_facts.services | default({}))  # Sólo si el unit existe
  register: tv_systemd
  failed_when: false
  become: yes

# 5) Arranque vía CLI por compatibilidad con versiones antiguas (no falla si no existe)
- name: teamviewer --daemon enable (compat)
  command: teamviewer --daemon enable
  register: tv_enable_cli
  changed_when: "'Enabling' in tv_enable_cli.stdout or 'enable' in tv_enable_cli.stdout or tv_enable_cli.rc == 0"
  failed_when: false
  become: yes

- name: teamviewer --daemon start (compat)
  command: teamviewer --daemon start
  register: tv_start_cli
  changed_when: "'Starting' in tv_start_cli.stdout or 'start' in tv_start_cli.stdout or tv_start_cli.rc == 0"
  failed_when: false
  become: yes

# 6) Esperar a que realmente quede activo
- name: Esperar a que teamviewerd quede activo
  shell: "systemctl is-active teamviewerd.service || systemctl is-active teamviewer.service"
  register: tv_active
  retries: 8
  delay: 2
  until: tv_active.rc == 0
  changed_when: false
  failed_when: false
  become: yes

- name: Traer logs de teamviewerd si no está activo
  shell: "journalctl -u teamviewerd --no-pager -n 200 || true"
  register: tv_journal
  when: tv_active.rc != 0
  changed_when: false
  failed_when: false
  become: yes

- name: Mostrar resumen de estado y logs si hubo problema
  debug:
    msg:
      - "systemd result: {{ tv_systemd.results | map(attribute='name') | list }}"
      - "CLI enable rc={{ tv_enable_cli.rc }} start rc={{ tv_start_cli.rc }}"
      - "is-active: {{ tv_active.stdout | default('n/a') }}"
      - "journal (ultimas lineas):"
      - "{{ tv_journal.stdout_lines | default(['<sin logs>']) }}"
  when: tv_active.rc != 0

# --- AnyDesk: Unattended Access con contraseña fija ---

- name: AnyDesk | asegurar servicio arriba
  systemd:
    name: anydesk.service
    enabled: yes
    state: started
  become: yes
  failed_when: false

# --- AnyDesk: poner contraseña unattended con 3 métodos ---

# Método 1: argumento directo (algunas versiones lo aceptan)
- name: AnyDesk | set password (arg)
  shell: bash -lc "anydesk --set-password '{{ anydesk_password }}'"
  become: yes
  register: ad_set1
  no_log: true
  changed_when: ad_set1.rc == 0
  failed_when: false
  when:
    - anydesk_password is defined
    - (anydesk_password | length) >= 8

# Método 2: doble entrada por pipe (nuevo + confirm)
- name: AnyDesk | set password (pipe doble)
  shell: >
    timeout 12s bash -lc
    "printf '%s\n%s\n' '{{ anydesk_password }}' '{{ anydesk_password }}' | anydesk --set-password"
  become: yes
  register: ad_set2
  no_log: true
  changed_when: ad_set2.rc == 0
  failed_when: false
  when:
    - anydesk_password is defined
    - (anydesk_password | length) >= 8
    - ad_set1 is defined and ad_set1.rc != 0

# Método 3: expect (interactivo; cubre inglés/español)
- name: AnyDesk | instalar pexpect (para expect)
  apt:
    name: python3-pexpect
    state: present
    update_cache: yes
  become: yes
  when:
    - anydesk_password is defined
    - (anydesk_password | length) >= 8
    - ad_set1 is defined and ad_set1.rc != 0
    - ad_set2 is defined and ad_set2.rc != 0

- name: AnyDesk | set password (expect)
  expect:
    command: anydesk --set-password
    responses:
      '(?i)new.*(password|contraseña)': "{{ anydesk_password }}"
      '(?i)confirm.*(password|contraseña)': "{{ anydesk_password }}"
  become: yes
  register: ad_set3
  no_log: true
  changed_when: ad_set3.rc == 0
  failed_when: ad_set3.rc != 0
  when:
    - anydesk_password is defined
    - (anydesk_password | length) >= 8
    - ad_set1 is defined and ad_set1.rc != 0
    - ad_set2 is defined and ad_set2.rc != 0

- name: AnyDesk | reiniciar servicio (algunas versiones lo requieren)
  shell: anydesk --restart-service || systemctl restart anydesk.service
  become: yes
  changed_when: false
  failed_when: false

- name: AnyDesk | estado + ID
  shell: |
    anydesk --get-status || true
    anydesk --get-id || true
  register: anydesk_info
  changed_when: false
  failed_when: false

- name: AnyDesk | mostrar info
  debug:
    msg:
      - "status/ID de {{ inventory_hostname }}:"
      - "{{ anydesk_info.stdout_lines | default([]) }}"